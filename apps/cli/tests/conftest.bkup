import re
import subprocess

import pytest
from sonar_cli import sonar
from sonar_cli.annotation import Annotator
from sonar_cli.cache import sonarCache
from sonar_cli.config import ANNO_TOOL_PATH


# Assuming Django API is running on localhost
API_BASE_URL = "http://127.0.0.1:8000/api"
ACCESION_SARSCOV2 = "MN908947.3"


# PYTEST FIXTURES
@pytest.fixture(autouse=True)
def mock_workerpool_methods(monkeypatch):  # noqa: C901
    """Mock mpire's WorkerPool methods for testing
    This is necessary to work around crashes caused by trying to calculate
    coverage with multiprocess subprocesses, and also to make the tests
    reproducible (ordered).
    """

    def mock_imap_unordered(
        self, func, args=(), kwds={}, callback=None, error_callback=None
    ):
        """Mock imap_unordered to work sequentially and yield each result.

        If the WorkerPool instance has `shared_objects`, mimic mpire by
        passing them as the first argument to the worker function.
        """
        # Prefer any shared objects recorded at WorkerPool construction by our
        # patched __init__ (see below). Fall back to common attribute names
        # for older mpire implementations.
        shared = getattr(self, "_mock_shared_objects", None)
        if shared is None:
            for attr_name in (
                "shared_objects",
                "_shared_objects",
                "shared",
                "_shared",
                "shared_object",
                "_shared_object",
            ):
                if hasattr(self, attr_name):
                    shared = getattr(self, attr_name)
                    break
        # normalize shared to a tuple of positional shared args
        if isinstance(shared, (list, tuple)):
            shared_args = tuple(shared)
        elif shared is None:
            shared_args = ()
        else:
            shared_args = (shared,)

        for arg in args:
            # DEBUG: print shapes to help diagnose argument mismatch in tests
            try:
                print("[mock_imap_unordered] shared_args=", repr(shared_args))
                print("[mock_imap_unordered] arg=", repr(arg), "type=", type(arg))
                # inspect kwds for any shared_objects passed here
                try:
                    print("[mock_imap_unordered] kwds=", repr(kwds))
                except Exception:
                    pass
                # inspect self attributes for likely shared storage
                try:
                    attrs = [a for a in dir(self) if ("shared" in a or "obj" in a)]
                    if attrs:
                        print("[mock_imap_unordered] candidate attrs:", attrs)
                        for a in attrs:
                            try:
                                val = getattr(self, a)
                                print(
                                    f"[mock_imap_unordered] self.{a} type=",
                                    type(val),
                                    "repr=",
                                    repr(val)[:200],
                                )
                            except Exception:
                                pass
                except Exception:
                    pass
            except Exception:
                pass
            try:
                # If arg is a single-element sequence whose only element is
                # itself a sequence, flatten one level. This mirrors mpire's
                # behavior where task arguments may be passed as a single
                # tuple and ensures worker functions that expect multiple
                # positional batch args (e.g. (sample_batch, error_dir))
                # receive them correctly.
                if (
                    isinstance(arg, (tuple, list))
                    and len(arg) == 1
                    and isinstance(arg[0], (tuple, list))
                ):
                    effective_arg = arg[0]
                else:
                    effective_arg = arg

                if shared_args:
                    if isinstance(effective_arg, (tuple, list)):
                        try:
                            print(
                                "[mock_imap_unordered] effective_arg (seq)=",
                                repr(effective_arg),
                            )
                        except Exception:
                            pass
                        result = func(*shared_args, *effective_arg)
                    elif isinstance(effective_arg, dict):
                        try:
                            print(
                                "[mock_imap_unordered] effective_arg (dict)=",
                                repr(effective_arg),
                            )
                        except Exception:
                            pass
                        result = func(*shared_args, **effective_arg)
                    else:
                        try:
                            print(
                                "[mock_imap_unordered] effective_arg (single)=",
                                repr(effective_arg),
                            )
                        except Exception:
                            pass
                        result = func(*shared_args, effective_arg)
                else:
                    if isinstance(effective_arg, (tuple, list)):
                        result = func(*effective_arg)
                    elif isinstance(effective_arg, dict):
                        result = func(**effective_arg)
                    else:
                        result = func(effective_arg)
                if callback:
                    callback(result)
                yield result
            except Exception as e:
                if error_callback:
                    error_callback(e)
                else:
                    raise

    def mock_imap(self, func, args=(), kwds={}, callback=None, error_callback=None):
        """Mock imap to work sequentially and yield each result.

        Respect WorkerPool.shared_objects when present.
        """
        shared = None
        for attr_name in (
            "shared_objects",
            "_shared_objects",
            "shared",
            "_shared",
            "shared_object",
            "_shared_object",
        ):
            if hasattr(self, attr_name):
                shared = getattr(self, attr_name)
                break
        if isinstance(shared, (list, tuple)):
            shared_args = tuple(shared)
        elif shared is None:
            shared_args = ()
        else:
            shared_args = (shared,)

        for arg in args:
            try:
                if (
                    isinstance(arg, (tuple, list))
                    and len(arg) == 1
                    and isinstance(arg[0], (tuple, list))
                ):
                    effective_arg = arg[0]
                else:
                    effective_arg = arg

                if shared_args:
                    if isinstance(effective_arg, (tuple, list)):
                        result = func(*shared_args, *effective_arg)
                    elif isinstance(effective_arg, dict):
                        result = func(*shared_args, **effective_arg)
                    else:
                        result = func(*shared_args, effective_arg)
                else:
                    if isinstance(effective_arg, (tuple, list)):
                        result = func(*effective_arg)
                    elif isinstance(effective_arg, dict):
                        result = func(**effective_arg)
                    else:
                        result = func(effective_arg)
                if callback:
                    callback(result)
                yield result
            except Exception as e:
                if error_callback:
                    error_callback(e)
                else:
                    raise

    def mock_map_unordered(
        self,
        func,
        args=(),
        progress_bar=True,
        progress_bar_options={},
        kwds={},
        callback=None,
        error_callback=None,
    ):
        """Mock map_unordered to work sequentially and yield each result.

        Respect WorkerPool.shared_objects when present.
        """
        shared = None
        for attr_name in (
            "shared_objects",
            "_shared_objects",
            "shared",
            "_shared",
            "shared_object",
            "_shared_object",
        ):
            if hasattr(self, attr_name):
                shared = getattr(self, attr_name)
                break
        if isinstance(shared, (list, tuple)):
            shared_args = tuple(shared)
        elif shared is None:
            shared_args = ()
        else:
            shared_args = (shared,)

        for arg in args:
            try:
                if (
                    isinstance(arg, (tuple, list))
                    and len(arg) == 1
                    and isinstance(arg[0], (tuple, list))
                ):
                    effective_arg = arg[0]
                else:
                    effective_arg = arg

                if shared_args:
                    if isinstance(effective_arg, (tuple, list)):
                        result = func(*shared_args, *effective_arg)
                    elif isinstance(effective_arg, dict):
                        result = func(*shared_args, **effective_arg)
                    else:
                        result = func(*shared_args, effective_arg)
                else:
                    if isinstance(effective_arg, (tuple, list)):
                        result = func(*effective_arg)
                    elif isinstance(effective_arg, dict):
                        result = func(**effective_arg)
                    else:
                        result = func(effective_arg)
                if callback:
                    callback(result)
                yield result
            except Exception as e:
                if error_callback:
                    error_callback(e)
                else:
                    raise

    monkeypatch.setattr("mpire.WorkerPool.imap_unordered", mock_imap_unordered)
    monkeypatch.setattr("mpire.WorkerPool.imap", mock_imap)
    monkeypatch.setattr("mpire.WorkerPool.map_unordered", mock_map_unordered)

    # Patch WorkerPool.__init__ to record the shared_objects argument in a
    # predictable place. This is safer than guessing internal attribute names
    # which can vary between mpire versions. We wrap the original __init__
    # to stash the shared_objects on the instance as `_mock_shared_objects`.
    import mpire

    original_init = mpire.pool.WorkerPool.__init__

    def _mocked_init(self, *a, shared_objects=None, **kw):
        # store for our mock lookup
        setattr(self, "_mock_shared_objects", shared_objects)
        # call original init with same args
        return original_init(self, *a, shared_objects=shared_objects, **kw)

    monkeypatch.setattr("mpire.pool.WorkerPool.__init__", _mocked_init)


@pytest.fixture(scope="session")
def api_url():
    return API_BASE_URL


@pytest.fixture(scope="session")
def accesion_SARSCOV2():
    return ACCESION_SARSCOV2


@pytest.fixture(scope="session")
def tmpfile_name(tmpdir_factory):
    my_tmpdir = str(tmpdir_factory.mktemp("sonar-cli_test"))
    # .join(
    #        next(tempfile._get_candidate_names())
    #    )
    print("tmp_path:", my_tmpdir)
    yield my_tmpdir


def split_cli(s):
    """Split a string into a list of individual arguments, respecting quotes"""
    return re.findall(r'(?:[^\s,"\']|"(?:\\.|[^"])*")+', s)
    # re.findall(r'(?:[^\s,"]|"(?:\\.|[^"])*")+', s)


def run_cli(s):
    """Helper function to simulate running the command line ./sonar <args>"""
    return sonar.main(sonar.parse_args(split_cli(s)))


def run_cli_cmd(command):
    """
    A helper function to run the CLI command over cmd or subprocess.
    """
    return subprocess.run(command, shell=True)


@pytest.fixture(scope="session")
def annotator(accesion_SARSCOV2, tmpfile_name):
    sonar_cache = sonarCache(
        db=API_BASE_URL,
        outdir=tmpfile_name,
        logfile="import.log",
        allow_updates=False,
        temp=False,
        debug=False,
        disable_progress=False,
        refacc=accesion_SARSCOV2,
    )
    return Annotator(
        annotator_exe_path=ANNO_TOOL_PATH,
        cache=sonar_cache,
    )
